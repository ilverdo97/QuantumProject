    ''''
        match operator:
            case '+':
                qc = Addiction(a, b, cl, first, second, nqubit)
                printResult(first, second, qc, a, cl, nqubit, operator)  
            case '-':
                qc = Sottra(a, b, cl, first, second, nqubit)
                printResult(first, second, qc, a, cl, nqubit, operator)  
            case '*':
                qc = Multi(a, b, cl, first, second, input2, nqubit)
                printResult(first, second, qc, a, cl, nqubit, operator)  
            case '/':
                qc = Division(a, b, accumulator, cl, first, second, nqubit)
                printResult(first, second, qc, accumulator, cl, nqubit, operator)

        print(bcolors.OKCYAN + '#'*150 + bcolors.ENDC)


from qiskit import *
from operations.operationss import *

def NqubitOperator(operator, len1, len2, first, second):

    if operator == '+' or operator == '-' or operator == '/':
        if len2>len1:
            first,second = second, first
            len2, len1 = len1, len2
        second = ("0") * (len1 - len2) + second
        tmpnqbit = len1
    elif operator == '*' :
        # Padding 'first' the same lenght of 'result'
        # since result can have at max len(first) + len(second) bits when multiplying
        first = ("0") * (len2) + first
        tmpnqbit = len1 + len2

    return tmpnqbit, len1, len2, first, second

def Addiction(a, b, cl, first, second, nqubit):
    qc = QuantumCircuit(a, b, cl, name="qc")
    # Flip the corresponding qubit in register a if a bit in the string first is a 1
    initQubits(first, qc, a, nqubit)
    #initQubits(second, qc, a, nqubit)
    sum(a, b, qc)
    return qc

def Sottra(a, b, cl, first, second, nqubit):
    qc = QuantumCircuit(a, b, cl, name="qc")
    # Flip the corresponding qubit in register a if a bit in the string first is a 1
    initQubits(first, qc, a, nqubit)
    sub(a, b, qc)
    return qc

def Multi(a, b, cl, first, second, input2, nqubit):
    qc = QuantumCircuit(a, b, cl, name="qc")
    # Flip the corresponding qubit in register a if a bit in the string first is a 1
    initQubits(first, qc, a, nqubit)
    initQubits(second, qc, a, nqubit)
    mul(a, input2, b, qc)
    return qc

def Division(a, b, accumulator, cl, first, second, nqubit):
    qc = QuantumCircuit(a, b, accumulator, cl, name="qc")
    # Flip the corresponding qubit in register a and b if a,b bit in the string first,second is a 1
    initQubits(first, qc, a, nqubit)
    initQubits(second, qc, b, nqubit)

    div(a, b, accumulator, cl, qc, 0)
    return qc

def initQubits(str, qc, reg, n):
    # Flip the corresponding qubit in register if a bit in the string is a 1
    for i in range(n):
        if str[i] == "1":
            qc.x(reg[n-(i+1)])
    '''


    d = QuantumRegister(1)
    circ.add_register(d)
    circ.x(d[0])

    c_dividend_str = '0'

    while c_dividend_str[0] == '0':
        sub(dividend, divisor, circ)
        sum(accumulator, d, circ)

        for i in range(len(dividend)):
            circ.measure(dividend[i], c_dividend[i])

        result = execute(circ, backend=Aer.get_backend('qasm_simulator'), shots=10).result()

        counts = result.get_counts("qc")
        # print(counts)
        c_dividend_str = list(counts.keys())[0]  # .split()[0]

        a = qiskit.QuantumRegister(nqubit + 1, "a")
        b = qiskit.QuantumRegister(nqubit + 1, "b")
        cl = qiskit.ClassicalRegister(nqubit + 1, "cl")
        qc = qiskit.QuantumCircuit(a, b, cl, name="qc")

        initQubits(first, qc, a, nqubit)
        initQubits(second, qc, b, nqubit)

    sub(accumulator, d, circ)

    ##############################################################

            # Add a qbit to 'a' and 'b' in case of overflowing results
        # (the result is only read on 'a' or 'accumulator', but since 'a' (or 'accumulator') and 'b'
        # should have the same lenght, we also add a qbit to 'b')
        a = qiskit.QuantumRegister(nqubit + 1, "a")
        b = qiskit.QuantumRegister(nqubit + 1, "b")
        accumulator = qiskit.QuantumRegister(nqubit + 1, "accumulator")
        cl = qiskit.ClassicalRegister(nqubit + 1, "cl")

          if operator == '+' or operator == '-' or operator == '*' or operator == '^':
            qc = qiskit.QuantumCircuit(a, b, cl, name="qc")
            # Flip the corresponding qubit in register a if a bit in the string first is a 1
            initQubits(first, qc, a, nqubit)
            # Flip the corresponding qubit in register b if b bit in the string second is a 1
            if operator == '+' or operator == '-':
                initQubits(second, qc, b, nqubit)

            if operator == '+':
                sum(a,b,qc)
                printResult(first, second, qc, a, cl, nqubit, operator)
            elif operator == '-':
                sub(a,b,qc)
                printResult(first, second, qc, a, cl, nqubit, operator)
            elif operator == '*':
                multiply(a,input2,b,qc)
                printResult(first, second, qc, b, cl, nqubit ,operator)
            elif operator == '^':
                prtFirst, prtSecond, prtResult, prtProb = exponential(a, first, input1, input2, operator, b, qc, cl, nqubit)
                printResultADVANCE(prtFirst, prtSecond, prtResult, prtProb, operator, nqubit)

        elif operator == '/':
            qc = qiskit.QuantumCircuit(a, b, accumulator, cl, name="qc")
            # Flip the corresponding qubit in register a and b if a,b bit in the string first,second is a 1
            initQubits(first, qc, a, nqubit)
            initQubits(second, qc, b, nqubit)

            prtFirst, prtSecond, prtResult, prtProb = div(first, second, a, b, qc, nqubit, cl)
            printResultADVANCE(prtFirst, prtSecond, prtResult, prtProb, operator, nqubit)